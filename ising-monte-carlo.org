* Question 5
  
** A reliable random number generator

We shall use  =numpy.random= as our random number generator. It uses the /Mersenne twister/ pseudo-random number generator, so we would expect to get a uniform random distribution. We test this here. Let us generate a 10000 random numbers and plot them.

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt

plt.plot(range(10000), np.random.random(10000), '.')
plt.savefig('images/numpy-random.png')
plt.show()
#+END_SRC

#+RESULTS:

[[./images/numpy-random.png]]

That looks pretty uniform!



** 2-D Ising Model Simulator

Here is a script that simulates the 2D Ising Model. The main ideas are as follows:

-  We create a n \times n lattice with a random spin configuration

- For the purposes of our Monte Carlo simulation we start off by randomly flipping a spin and calculate the change in energy, \Delta E

- If \Delta E is negative, we accept the new configuration

- If \Delta E is positive, we select a random number between 0 and 1, and accept the configuration only if the number is less than \(e^{-\Delta E / k_{B}T}\). This is the Metropolis techinque. This saves computation time by selecting more probable configurations.

- We use periodic boundary conditions. This effectively reduces the geometry of the problem to a torus.

- To simulate over a range of temperatures, we will submit jobs to the queue system for every temperature.  This is useful, especially for large lattice sizes where a lot of simulations are required to reach convergence.
  
#+BEGIN_SRC python :tangle ising.py
from __future__ import division
import numpy as np

def init_lattice(n):

    '''Create a nxn lattice with random spin configuration'''
    
    lattice = np.random.choice([1, -1], size=(n, n))
    return lattice


def deltaE(S0, Sn, J, H):

    '''Energy difference for a spin flip'''
    
    return 2 * S0 * (H + J * Sn)


def ising(n=200, nsteps=500000, H=0, J=1, T=1, count_spins = False, countij = [1,1]):

    '''Ising Model Simulator. If count_spins = True, only flipping behavior of 1 site is studied.'''
    
    lattice = init_lattice(n)
    energy = 0
    energies = []
    spins = []
    spin = np.sum(lattice)
    icount, jcount = countij
    counted_spins = [lattice[icount, jcount]]
    counted_intervals = []
    for step in xrange(nsteps):

        i = np.random.randint(n)
        j = np.random.randint(n)

        # Periodic Boundary Condition
        Sn = lattice[(i - 1) % n, j] + lattice[(i + 1) % n, j] + \
             lattice[i, (j - 1) % n] + lattice[i, (j + 1) % n]

        dE = deltaE(lattice[i, j], Sn, J, H)

        if dE < 0 or np.random.random() < np.exp(-dE/T):
            lattice[i, j] = -lattice[i, j]
            energy += dE
            energies.append(energy)
         # Note that the spin is collected at every step
            spin += 2*lattice[i, j]
        
        if count_spins:
            ispin = lattice[icount, jcount]
            if ispin != counted_spins[-1]:
                counted_spins.append(ispin)
                counted_interval = step - sum(counted_intervals)

                counted_intervals.append(counted_interval)            
        spins.append(spin)
    if not count_spins:
        return lattice, energies, spins
    else:
        return counted_spins, counted_intervals

def ising1000(n=1000, nsteps=10000000000, H=0, J=1, T=1):

    '''Ising Model Simulator. Special case for very large lattices.
    To reduce memory usage,
    Spin is added to the array every 1000 steps.
    Energies are not returned.'''
    
    lattice = init_lattice(n)
    energy = 0

    spins = []
    spin = np.sum(lattice)
    for istep, step in enumerate(xrange(nsteps)):

        i = np.random.randint(n)
        j = np.random.randint(n)

        # Periodic Boundary Condition
        Sn = lattice[(i - 1) % n, j] + lattice[(i + 1) % n, j] + \
             lattice[i, (j - 1) % n] + lattice[i, (j + 1) % n]

        dE = deltaE(lattice[i, j], Sn, J, H)

        if dE < 0 or np.random.random() < np.exp(-dE/T):
            lattice[i, j] = -lattice[i, j]
            energy += dE
            spin += 2*lattice[i, j]
        if istep % 1000 == 0:
            spins.append(spin)
    return lattice, spins

def write_job_script(wd='./', n=10, s=1000, i=1, T=1., nprocs=1, pe='smp', name = 'batch', q = 'long'):
    '''
    This is a function that writes a script to submit MC jobs
    '''
    py_file = '/afs/crc.nd.edu/user/p/pmehta1/ising-monte-carlo/spins.py'
    script='''#!/bin/bash
#$ -N {0}
#$ -pe {1} {2}
#$ -q {3}
#$ -cwd
'''.format(name, pe, nprocs, q)
       
    if nprocs > 1:
        cmd = 'mpirun -np $NSLOTS python'
        script+='{6} {5} -n {0} -s {1} -i {2} -t {3} -w {4}'.format(n, s, i, T, wd, py_file, cmd)

    else:
        script+='python {5} -n {0} -s {1} -i {2} -t {3} -w {4}'.format(n, s, i, T, wd, py_file)

    with open('{0}/qscript'.format(wd), 'w') as f:
        f.write(script)

def run_job(wd):
    '''
    Submit job to the queue
    '''
    import os
    from subprocess import Popen, PIPE
    cwd = os.getcwd()
    os.chdir(wd)
    p = Popen(['qsub', 'qscript'], stdout=PIPE, stderr=PIPE)
    out, err = p.communicate()
    
    if out == '' or err !='':
        raise Exception('something went wrong in qsub:\n\n{0}'.format(err))
    jobid = out.split()[2]
    f = open('jobid', 'w')
    f.write(jobid)
    f.close()
    os.chdir(cwd)
    return out.strip()    
#+END_SRC

#+RESULTS:


** Average Spin Trajectories

Now we plot the average spin trajectories at three different temperatures. 

*Note:* The spin is collected at every step of the Monte Carlo simulation, regardless of whether we accepted the energy or not.

#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ising import *

temperatures = [0.5, 2.27, 5.0]

for T in temperatures:

    lattice, energies, spins = ising(n=20, nsteps = 500000, T=T)
    spins = np.array(spins) / 20. ** 2
    plt.plot(range(len(spins)), spins, label = 'T = {0}'.format(T))
plt.legend(loc = 'best')
plt.xlabel('nSteps')
plt.ylabel('Average Spin')
plt.ylim(-1.2, 1.2)
plt.savefig('images/average-spin.png')
plt.show()

#+END_SRC

#+RESULTS:

[[./images/average-spin.png]]

This looks pretty much like what one would expect. At a low temperature the average spin per site is 1, meaning that all the points in the lattice have the same spin. At a temperature close to Onsager's T_{c}, the system has an intermediate spin, and at a high temperature, the system has no net spin. The high and low temperature plots seem to converge faster than the one intermediate temperature. We also noticed that the simulations were getting stuck in a local minima from time to time, though we have not shown that here.



** Magnetization and Susceptibility
In this section, we calculate the magnetization and susceptibility at different lattice sizes and temperatures.   
*** Submission to the queue
    
This is the python executable we will use to submit to the queue.
#+BEGIN_SRC python :tangle spins.py
#!/usr/bin/env python
import os
from ising import ising, ising1000
import sys,getopt
opts,args = getopt.getopt(sys.argv[1:],'n:s:i:t:w')

for key, val in opts:

    if key == '-n': n = int(val)
    elif key == '-s': nsteps = int(val)
    elif key == '-t': T = float(val)
    elif key == '-i': index = int(val)
    elif key == '-w': wd = str(val)

if n < 500:
    lattice, energies, spins = ising(n=n, nsteps=nsteps, T=T)
else:
    lattice, spins = ising1000(n=n, nsteps=nsteps, T=T)
    
with open(os.path.join(wd,'temp-{1}.out'.format(wd, index)), 'w') as f:
    for i, spin in enumerate(spins):
        if i % 1000 == 0:
            f.write("{0}\t{1}\n".format(i, spin))   
#+END_SRC

#+RESULTS:

We submit jobs here for multiple lattice sizes and temperatures.

#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ising import *
import os

Ns = [10, 20, 50, 100, 1000]  # System Size
T_Tcs = np.linspace(0.5, 1.7, 30)  # T/Tc
Tc = 2.268  # Onsager's Tc

for n in Ns:
    for i, T_Tc in enumerate(T_Tcs):
        T = T_Tc*Tc
        wd = 'magnetization/size-{0}/temp-{1}'.format(n, i)
        if not os.path.exists(wd): 
            os.makedirs(wd)
        if n !=1000:
            write_job_script(wd=wd, n=n, s= n * 1000000, T=T, i=i)
        else:
            write_job_script(wd=wd, n=n, s= n * 1000000, T=T, i=i, nprocs = 1, q ='long')
        run_job(wd)
#+END_SRC

#+RESULTS:

*** Magnetization
Here we plot the magnetization. We see that for larger lattice sizes, the system has not reached equilibirum. Otherwise the plot looks like one would expect, i.e, fully magnetized at low temperatures, disordered at higher temperatures, transitioning at the critical temperature. The transition is sharper at larger lattice sizes.

#+BEGIN_SRC python
from __future__ import division
import matplotlib.pyplot as plt
from ising import *
import os

Ns = [10, 20, 50, 100, 1000]  # System Size
T_Tcs = np.linspace(0.5, 1.7, 30)  # T/Tc
Tc = 2.268  # Onsager's Tc

for n in Ns:
    avgspins = []
    for i, T_Tc in enumerate(T_Tcs):
        T = T_Tc*Tc
        indices, spins = np.loadtxt('magnetization/size-{0}/temp-{1}/temp-{1}.out'.format(n,i), unpack =True)
        spins = spins[int(len(spins)/2):]
        avgspin = np.sum(np.abs(spins)) / n ** 2 / len(spins)
        avgspins.append(avgspin)
    plt.plot(T_Tcs, avgspins, 'o-', label = 'L = {0}'.format(n))

plt.xlabel('T/T$_{c}$', fontsize = 16)
plt.ylabel('<M$_{L}$>', fontsize = 16)
plt.legend()
plt.savefig('images/magnetization.png')
plt.show()
#+END_SRC

#+RESULTS:

[[./images/magnetization.png]]

*** Susceptibility

Susceptibility is the second derivative of the energy and measures the extent to which the lattice will be magnitized. It is discontinuous at the critical temperature.

#+BEGIN_SRC python
from __future__ import division
import matplotlib.pyplot as plt
from ising import *
import os

Ns = [10, 20, 50, 100, 1000]  # System Size
T_Tcs = np.linspace(0.5, 1.7, 30)  # T/Tc
Tc = 2.268  # Onsager's Tc

for n in Ns:
    avgspins = []
    Xs = []
    for i, T_Tc in enumerate(T_Tcs):
        T = T_Tc*Tc
        indices, spins = np.loadtxt('magnetization/size-{0}/temp-{1}/temp-{1}.out'.format(n,i), unpack =True)
        spins = spins[int(len(spins)/2):]
        avgspin = np.sum(np.abs(spins)) / n ** 2 / len(spins)
        X =  np.abs(np.sum(((np.abs(spins) / n ** 2) ** 2)) \
                    / len(spins) - avgspin) / T
        avgspins.append(avgspin)
        Xs.append(X)
    plt.plot(T_Tcs, Xs, 'o-', label = 'L = {0}'.format(n))
plt.xlabel('T/T$_{c}$', fontsize = 16)
plt.ylabel('$\chi$', fontsize = 16)
plt.legend()
plt.savefig('images/susseptibility.png')
plt.show()
#+END_SRC

#+RESULTS:

[[./images/susseptibility.png]]



** Finite Size Scaling

For a system size of 50 let us run a few simulations around the critical point so that we can fit it to our scaling relation.

*** Job Submission
    
#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ising import *
import os

Ns = [50]  # System Size
T_Tcs = np.linspace(0.9, 1.1, 100)  # T/Tc
Tc = 2.268  # Onsager's Tc

for n in Ns:
    for i, T_Tc in enumerate(T_Tcs):
        T = T_Tc*Tc
        wd = 'finite-size-scaling/size-{0}/temp-{1}'.format(n, i)
        if not os.path.exists(wd): 
            os.makedirs(wd)
        write_job_script(wd=wd, n=n, s= n * 1000000, T=T, i=i)
        run_job(wd)
#+END_SRC

#+RESULTS:

*** Fitting
#+BEGIN_SRC python
from __future__ import division
import numpy as np
import matplotlib.pyplot as plt
from pycse import nlinfit
from ising import *

Ns = [50]  # System Size
T_Tcs = np.linspace(0.9, 1.1, 100)  # T/Tc
Tc = 2.268  # Onsager's Tc

for n in Ns:
    avgspins = []
    avgspinsqs = []
    for i, T_Tc in enumerate(T_Tcs):
        T = T_Tc*Tc
        indices, spins = np.loadtxt('finite-size-scaling/size-{0}/temp-{1}/temp-{1}.out'.format(n,i), unpack =True)
        spins = spins[int(len(spins)/2):]
        avgspin = np.sum(np.abs(spins)) / n ** 2 / len(spins)
        avgspinsq =  np.abs(np.sum(((np.abs(spins) / n ** 2) ** 2)) / len(spins) - avgspin) / T
        avgspins.append(avgspin)
        avgspinsqs.append(avgspinsq)

# data
Ts = T_Tcs * Tc

Ts = Ts[25:75]
avgspinsqs = avgspinsqs[25:75]

plt.plot(Ts, avgspinsqs, 'o')

def M_fit(Ts, Tcinf, beta, a):
    
    M = a * np.abs((Ts - Tcinf) / Tcinf) ** beta
    return M

guess = [2.23, -1.7, 1]
pars, pint, SE = nlinfit(M_fit, Ts, avgspinsqs, guess, alpha=0.05)
Tcinf, beta, a = pint
#Tfit = np.linspace(Ts[6], Ts[18])

Tfit = np.linspace(Ts.min(), Ts.max())
print pars
#M = M_fit(Tfit, *pars)
#print np.size(Tfit), np.size(M)
#print M
plt.plot(Tfit, M_fit(Tfit, *pars))
#plt.savefig('images/eos-uncertainty.png')

#print '95% confidence intervals'
#print 'V0 = {0} bohr**3'.format(V0)
#print 'E0 = {0} Ha'.format(E0)
#print 'B0 = {0} GPA'.format([x * 29421.010901602753 for x in B0])
plt.show()
#+END_SRC

#+RESULTS:
: [ 2.23685625 -0.04968195  0.0648086 ]


** Extra Credit

We see that at high temperatures, the spin flips at short intervals. As we decrease the temperature, the spin hardly flips because the system becomes ordered.

#+BEGIN_SRC python
from ising import *
import matplotlib.pyplot as plt
temperatures = np.linspace(1.7, 0.5, 6) * 2.26

ij = [2, 2]
for i, T in enumerate(temperatures):
    counted_spins, counted_intervals = ising(n=10,
                                             nsteps=1000000,
                                             H=0,
                                             J=1,
                                             T=T, 
                                             count_spins=True,
                                             countij=ij)
    plt.subplot(3,2,i+1)
    plt.hist(counted_intervals, 50)
    plt.locator_params(nbins=4)
    plt.title('T/T$_{{c}}$ = {0}'.format(T))
    plt.xlabel('Flip Interval Frequency')
    plt.ylabel('No. of occurances')
plt.tight_layout()
plt.savefig('images/histograms.png')
plt.show()
#+END_SRC

#+RESULTS:

[[./images/histograms.png]]


** Nlinfit test

#+BEGIN_SRC python
from pycse import *
import matplotlib.pyplot as plt

x = np.arange(10)
y = x**2 + np.random.random(10)*2
print x , y
plt.plot(x,y)
#plt.show()

def func(x, a):

   return x**a

p, pint, se = nlinfit(func, x, y, 3)

print p
plt.plot(x, x**p)
#def func
plt.show()
#+END_SRC

#+RESULTS:
: [0 1 2 3 4 5 6 7 8 9] [  0.14825736   1.16691747   4.22080684  10.17593107  16.1183198
:   26.82922114  37.29249587  49.31862283  64.13961865  81.82408933]
: [ 2.00562762]

   
** Gezelter's Code

#+BEGIN_SRC python
from __future__ import division
from math import exp
from random import randrange,choice,random
from numpy import zeros, sum
import numpy as np
import matplotlib.pyplot as plt

def init_ising_lattice(n):
    lattice = zeros((n,n),dtype=int)
    options = [-1,1]
    for i in range(n):
        for j in range(n):
            lattice[i,j] = choice(options)
    return lattice

def energydiff(S0,Sn,J,H): return 2*S0*(H+J*Sn)

def ising(n=200,nsteps=500000,H=0,J=1,T=1):
    lattice = init_ising_lattice(n)
    energy = 0
    
    energies = []
    mags = []
    for step in range(nsteps):
        i = randrange(n)
        j = randrange(n)
        Sn = lattice[(i-1)%n,j]+lattice[(i+1)%n,j]+\
             lattice[i,(j-1)%n]+lattice[i,(j+1)%n]
        dE = energydiff(lattice[i,j],Sn,J,H)
        if dE < 0 or np.random.random() < exp(-dE/T):
            lattice[i,j] = -lattice[i,j]
            energy += dE
        
            energies.append(energy)
        mag = np.sum(lattice)/n**2
        mags.append(mag)
    return lattice,energies, mags

# Plotting Energies
for T in [8.04]:

    lattice, energies, mags = ising(T=T)
    plt.plot(range(len(energies)), energies)

plt.show()
#+END_SRC

#+RESULTS:

   
** Tinkter
   
#+BEGIN_SRC python
# ising.py
# Simulates the two-dimensional Ising model using the Metropolis algorithm
# This version uses Tkinter for the GUI
# By Dan Schroeder, Weber State University, January 2013

import Tkinter, numpy, random, math

size = 100                           # number of sites in a lattice row (change if desired)
squareWidth = 4                    # width of one site in pixels (change if desired)
canvasWidth = size * squareWidth    # full width of canvas in pixels
s = numpy.ones((size, size), int)   # 2D array of dipoles (1=up, -1=down)
running = False                     # will be true when simulation is running

theWindow = Tkinter.Tk()            # create the GUI window
theWindow.title("Ising Model")
theWindow.geometry('+50+50')        # get the window away from the corner

# Here's the Canvas where we draw the lattice using a Tkinter PhotoImage:
theCanvas = Tkinter.Canvas(theWindow, width=canvasWidth, height=canvasWidth)
theCanvas.pack()                    # put it at the top of the window
theImage = Tkinter.PhotoImage(width=canvasWidth, height=canvasWidth)
theCanvas.create_image((0, 0), image=theImage, anchor="nw", state="normal")
# The coordinates (3, 3) are a kludge to eliminate a mysterious offset that occurs otherwise.

# Function called when Start/Stop button is pressed:
def startStop():
    global running
    running = not running
    if running:
        goButton.config(text="Pause")
    else:
        goButton.config(text="Resume")

# Create the GUI controls:
controlFrame = Tkinter.Frame(theWindow)        # a frame to hold the GUI controls
controlFrame.pack()                            # put it below the canvas
tLabel = Tkinter.Label(controlFrame, text="Temperature: ")
tLabel.pack(side="left")
tSlider = Tkinter.Scale(controlFrame, from_=0.01, to=10.0, resolution=0.01, length=120, orient="horizontal")
tSlider.pack(side="left")
tSlider.set(2.27)                              # set to critical temperature initially
spacer = Tkinter.Frame(controlFrame, width=40)
spacer.pack(side="left")
goButton = Tkinter.Button(controlFrame, text="Start", width=8, command=startStop)
goButton.pack(side="left")

# Function to color the square representing site (i,j):
def colorSquare(i, j):
    theColor = "#7000ff" if s[i,j]==1 else "#ffffff"    # purple and white
    theImage.put(theColor, to=(i*squareWidth,j*squareWidth,(i+1)*squareWidth,(j+1)*squareWidth))
    # the "put" function colors the indicated rectangle within the image

# Function to calculate energy change upon hypothetical flip (with pbc):
def deltaE(i,j):
    leftS = s[size-1,j] if i==0 else s[i-1,j]
    rightS = s[0,j] if i==size-1 else s[i+1,j]
    topS = s[i,size-1] if j==0 else s[i,j-1]
    bottomS = s[i,0] if j==size-1 else s[i,j+1]
    return 2.0 * s[i,j] * (leftS + rightS + topS + bottomS)

# Main simulation "loop" schedules a call to itself upon completion:
def simulate():
    if running:
        T = tSlider.get()                    # get the current temperature
        for step in range(1000):             # (change the number of steps as desired)
            i = int(random.random()*size)    # choose a random row and column
            j = int(random.random()*size)
            eDiff = deltaE(i,j)
            if eDiff <= 0 or random.random() < math.exp(-eDiff/T):    # Metropolis!
                s[i,j] = -s[i,j]
                colorSquare(i, j)
    theWindow.after(1,simulate)              # come back in one millisecond

# Initialize to a random array, and draw it as we go:
for i in range(size):
    for j in range(size):
        s[i,j] = 1 if random.random()<0.5 else -1
        colorSquare(i,j)

simulate()                # start the simulation!
theWindow.mainloop()      # start the GUI event loop

#+END_SRC

#+RESULTS:






#+BEGIN_SRC sh
#!/bin/bash

for n in $(seq 231701 231800)

do
  qdel $n

done
#+END_SRC

#+RESULTS:
#+begin_example
pmehta1 has registered the job 231701 for deletion
pmehta1 has registered the job 231702 for deletion
pmehta1 has registered the job 231703 for deletion
pmehta1 has registered the job 231704 for deletion
pmehta1 has registered the job 231705 for deletion
pmehta1 has registered the job 231706 for deletion
pmehta1 has registered the job 231707 for deletion
pmehta1 has registered the job 231708 for deletion
pmehta1 has registered the job 231709 for deletion
pmehta1 has registered the job 231710 for deletion
pmehta1 has registered the job 231711 for deletion
pmehta1 has registered the job 231712 for deletion
pmehta1 has registered the job 231713 for deletion
pmehta1 has registered the job 231714 for deletion
pmehta1 has registered the job 231715 for deletion
pmehta1 has registered the job 231716 for deletion
pmehta1 has registered the job 231717 for deletion
pmehta1 has registered the job 231718 for deletion
pmehta1 has registered the job 231719 for deletion
pmehta1 has registered the job 231720 for deletion
pmehta1 has registered the job 231721 for deletion
pmehta1 has registered the job 231722 for deletion
pmehta1 has registered the job 231723 for deletion
pmehta1 has registered the job 231724 for deletion
pmehta1 has registered the job 231725 for deletion
pmehta1 has registered the job 231726 for deletion
pmehta1 has registered the job 231727 for deletion
pmehta1 has registered the job 231728 for deletion
pmehta1 has registered the job 231729 for deletion
pmehta1 has registered the job 231730 for deletion
pmehta1 has registered the job 231731 for deletion
pmehta1 has registered the job 231732 for deletion
pmehta1 has registered the job 231733 for deletion
pmehta1 has registered the job 231734 for deletion
pmehta1 has registered the job 231735 for deletion
pmehta1 has registered the job 231736 for deletion
pmehta1 has registered the job 231737 for deletion
pmehta1 has registered the job 231738 for deletion
pmehta1 has registered the job 231739 for deletion
pmehta1 has registered the job 231740 for deletion
pmehta1 has registered the job 231741 for deletion
pmehta1 has registered the job 231742 for deletion
pmehta1 has deleted job 231743
pmehta1 has deleted job 231744
pmehta1 has deleted job 231745
pmehta1 has deleted job 231746
pmehta1 has deleted job 231747
pmehta1 has deleted job 231748
pmehta1 has deleted job 231749
pmehta1 has deleted job 231750
pmehta1 has deleted job 231751
pmehta1 has deleted job 231752
pmehta1 has deleted job 231753
pmehta1 has deleted job 231754
pmehta1 has deleted job 231755
pmehta1 has deleted job 231756
pmehta1 has deleted job 231757
pmehta1 has deleted job 231758
pmehta1 has deleted job 231759
pmehta1 has deleted job 231760
pmehta1 has deleted job 231761
pmehta1 has deleted job 231762
pmehta1 has deleted job 231763
pmehta1 has deleted job 231764
pmehta1 has deleted job 231765
pmehta1 has deleted job 231766
pmehta1 has deleted job 231767
pmehta1 has deleted job 231768
pmehta1 has deleted job 231769
pmehta1 has deleted job 231770
pmehta1 has deleted job 231771
pmehta1 has deleted job 231772
pmehta1 has deleted job 231773
pmehta1 has deleted job 231774
pmehta1 has deleted job 231775
pmehta1 has deleted job 231776
pmehta1 has deleted job 231777
pmehta1 has deleted job 231778
pmehta1 has deleted job 231779
pmehta1 has deleted job 231780
pmehta1 has deleted job 231781
pmehta1 has deleted job 231782
pmehta1 has deleted job 231783
pmehta1 has deleted job 231784
pmehta1 has deleted job 231785
pmehta1 has deleted job 231786
pmehta1 has deleted job 231787
pmehta1 has deleted job 231788
pmehta1 has deleted job 231789
pmehta1 has deleted job 231790
pmehta1 has deleted job 231791
pmehta1 has deleted job 231792
pmehta1 has deleted job 231793
pmehta1 has deleted job 231794
pmehta1 has deleted job 231795
pmehta1 has deleted job 231796
pmehta1 has deleted job 231797
pmehta1 has deleted job 231798
pmehta1 has deleted job 231799
pmehta1 has deleted job 231800
#+end_example




** Functional form test

#+BEGIN_SRC python
import numpy as np

T = np.linspace(0.7, 2.0,100) *  2.268
Tc = 2.268

M = np.abs((T - Tc))**0.125

import matplotlib.pyplot as plt
plt.plot(T, M)
print M
plt.show()

#+END_SRC

#+RESULTS:
#+begin_example
[ 0.95300579  0.94768886  0.94215454  0.93638284  0.93035082  0.92403193
  0.91739527  0.91040448  0.90301642  0.89517933  0.88683034  0.87789196
  0.86826715  0.85783197  0.84642447  0.8338271   0.81973737  0.80371612
  0.78508838  0.76273247  0.73455818  0.69586884  0.63121174  0.51006994
  0.65616398  0.70940744  0.74404459  0.77010546  0.79115273  0.80888584
  0.82425454  0.83784603  0.85004977  0.86113794  0.87130856  0.88071039
  0.8894581   0.89764209  0.9053349   0.91259565  0.91947323  0.92600852
  0.93223607  0.93818534  0.94388171  0.94934713  0.9546008   0.95965955
  0.96453824  0.96925008  0.97380684  0.97821905  0.98249621  0.98664687
  0.99067878  0.994599    0.99841395  1.00212951  1.00575108  1.00928359
  1.01273163  1.01609939  1.01939079  1.02260943  1.02575869  1.02884168
  1.03186134  1.03482037  1.03772133  1.04056662  1.04335846  1.04609897
  1.04879012  1.05143379  1.05403174  1.05658562  1.059097    1.06156738
  1.06399816  1.06639068  1.0687462   1.07106593  1.07335102  1.07560256
  1.07782158  1.08000907  1.08216598  1.08429321  1.08639162  1.08846204
  1.09050525  1.09252202  1.09451305  1.09647905  1.09842067  1.10033857
  1.10223335  1.1041056   1.10595588  1.10778475]
#+end_example

