* Question 5
  
** A reliable random number generator

We shall use  =numpy.random= as our random number generator. It uses the /Mersenne twister/ pseudo-random number generator, so we would expect to get a uniform random distribution. We test this here. Let us generate a 10000 random numbers and plot them.

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt

plt.plot(range(10000), np.random.random(10000), '.')
plt.savefig('images/numpy-random.png')
plt.show()
#+END_SRC

#+RESULTS:

[[./images/numpy-random.png]]

That looks pretty uniform!



** 2-D Ising Model Simulator

Here is a script that simulates the 2D Ising Model. The main ideas are as follows:

-  We create a n \times n lattice with a random spin configuration

- For the purposes of our Monte Carlo simulation we start off by randomly flipping a spin and calculate the change in energy, \Delta E

- If \Delta E is negative, we accept the new configuration

- If \Delta E is positive, we select a random number between 0 and 1, and accept the configuration only if the number is less than \(e^{-\Delta E / k_{B}T}\). This is the Metropolis techinque. This saves computation time by selecting more probable configurations.

- We use periodic boundary conditions. This effectively reduces the geometry of the problem to a torus.
  
#+BEGIN_SRC python :tangle ising.py
from __future__ import division
import numpy as np

def init_lattice(n):

    '''Create a nxn lattice with random spin configuration'''
    
    lattice = np.random.choice([1, -1], size=(n, n))
    return lattice


def deltaE(S0, Sn, J, H):

    '''Energy difference for a spin flip'''
    
    return 2 * S0 * (H + J * Sn)


def ising(n=200, nsteps=500000, H=0, J=1, T=1, count_spins = False, ij = [1,1]):

    '''Ising Model Simulator'''
    
    lattice = init_lattice(n)
    energy = 0
    energies = []
    spins = []
    spin = np.sum(lattice)

    for step in xrange(nsteps):

        i = np.random.randint(n)
        j = np.random.randint(n)

        # Periodic Boundary Condition
        Sn = lattice[(i - 1) % n, j] + lattice[(i + 1) % n, j] + \
             lattice[i, (j - 1) % n] + lattice[i, (j + 1) % n]

        dE = deltaE(lattice[i, j], Sn, J, H)

        if dE < 0 or np.random.random() < np.exp(-dE/T):
            lattice[i, j] = -lattice[i, j]
            energy += dE
            energies.append(energy)
         # Note that the spin is collected at every step
            spin += 2*lattice[i, j]
        
        if count_spins:
            ispin = lattice[*ij]
        spins.append(spin)
    return lattice, energies, spins

def ising1000(n=1000, nsteps=10000000000, H=0, J=1, T=1):

    '''Ising Model Simulator. Special case for very large lattices.
    Spin is written every 1000 steps.'''
    
    lattice = init_lattice(n)
    energy = 0

    spins = []
    spin = np.sum(lattice)
    for istep, step in enumerate(xrange(nsteps)):

        i = np.random.randint(n)
        j = np.random.randint(n)

        # Periodic Boundary Condition
        Sn = lattice[(i - 1) % n, j] + lattice[(i + 1) % n, j] + \
             lattice[i, (j - 1) % n] + lattice[i, (j + 1) % n]

        dE = deltaE(lattice[i, j], Sn, J, H)

        if dE < 0 or np.random.random() < np.exp(-dE/T):
            lattice[i, j] = -lattice[i, j]
            energy += dE
            spin += 2*lattice[i, j]
        if istep % 1000 == 0:
            spins.append(spin)
    return lattice, spins

def write_job_script(wd='./', n=10, s=1000, i=1, T=1., nprocs=1, pe='smp', name = 'batch', q = 'long'):
    '''
    This is a function that writes a script to submit MC jobs
    '''
    
    script='''#!/bin/bash
#$ -N {0}
#$ -pe {1} {2}
#$ -q {3}
#$ -cwd
'''.format(name, pe, nprocs, q)
       
    if nprocs > 1:
        script+='mpirun -np $NSLOTS python /afs/crc.nd.edu/user/p/pmehta1/ising-monte-carlo/spins.py -n {0} -s {1} -i {2} -t {3} -w {4}'.format(n, s, i, T, wd)

    else:
        script+='python /afs/crc.nd.edu/user/p/pmehta1/ising-monte-carlo/spins.py -n {0} -s {1} -i {2} -t {3} -w {4}'.format(n, s, i, T, wd)

    with open('{0}/qscript'.format(wd), 'w') as f:
        f.write(script)

def run_job(wd):
    import os
    from subprocess import Popen, PIPE
    cwd = os.getcwd()
    os.chdir(wd)
    p = Popen(['qsub', 'qscript'], stdout=PIPE, stderr=PIPE)
    out, err = p.communicate()
    
    if out == '' or err !='':
        raise Exception('something went wrong in qsub:\n\n{0}'.format(err))
    jobid = out.split()[2]
    f = open('jobid', 'w')
    f.write(jobid)
    f.close()
    os.chdir(cwd)
    return out.strip()    
#+END_SRC

#+RESULTS:


** Average Spin Trajectories

Now we plot the average spin trajectories at three different temperatures. 

*Note:* The spin is collected at every step of the Monte Carlo simulation, regardless of whether we accepted the energy or not.

#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ising import *

temperatures = [0.5, 2.27, 5.0]

for T in temperatures:

    lattice, energies, spins = ising(n=20, nsteps = 500000, T=T)
    spins = np.array(spins) / 20. ** 2
    plt.plot(range(len(spins)), spins, label = 'T = {0}'.format(T))
plt.legend(loc = 'best')
plt.xlabel('nSteps')
plt.ylabel('Average Spin')
plt.ylim(-1.2, 1.2)
plt.savefig('images/average-spin.png')
plt.show()

#+END_SRC

#+RESULTS:

[[./images/average-spin.png]]

This looks pretty much like what one would expect. At a low temperature the average spin per site is 1, meaning that all the points in the lattice have the same spin. At a temperature close to Onsager's T_{c}, the system has an intermediate spin, and at a high temperature, the system has no net spin. The high and low temperature plots seem to converge faster than the one intermediate temperature. We also noticed that the simulations were getting stuck in a local minima from time to time, though we have not shown that here.



** Magnetization and Susceptibility
   
#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ising import *

Ns = [20]  # System Size
T_Tcs = np.linspace(0.5, 1.7, 20)  # T/Tc
Tc = 2.268  # Onsager's Tc

plt.figure()
ax1 = plt.subplot(211)
ax2 = plt.subplot(212)

for n in Ns:
    Ms = []  # Magnetization list
    Xs = []
    for T_Tc in T_Tcs:

        T = T_Tc * Tc
        lattice, energies, spins = ising(n=n, nsteps=500000, T=T)
        spins = np.array(spins)
        avg_M = np.abs(np.sum(spins) / len(spins))
        M_sq = np.sum(spins ** 2) / len(spins)

        X = 1 / T * (M_sq - avg_M**2)
        Ms.append(avg_M)
        Xs.append(X)

    ax1.plot(T_Tcs, Ms, 'o--', label = '${0}\\times{0}$'.format(n))
    ax2.plot(T_Tcs, Xs, 'o--')

plt.legend(loc = 'best')
ax1.set_ylabel('M$_{L}$')
ax2.set_ylabel('$\chi_{L}$')
plt.xlabel('T/T$_{c}$')
#ax2.set_yticks(np.arange(0.0, 0.3, 0.1))
ax1.legend(loc = 'best')
plt.savefig('images/magnetization.png')
plt.show()
#+END_SRC

#+RESULTS:


** Scripts
   
*** Submission python script
#+BEGIN_SRC python :tangle spins.py
#!/usr/bin/env python
import os
from ising import ising, ising1000
import sys,getopt
opts,args = getopt.getopt(sys.argv[1:],'n:s:i:t:w')

for key, val in opts:

    if key == '-n': n = int(val)
    elif key == '-s': nsteps = int(val)
    elif key == '-t': T = float(val)
    elif key == '-i': index = int(val)
    elif key == '-w': wd = str(val)

if n < 500:
    lattice, energies, spins = ising(n=n, nsteps=nsteps, T=T)
else:
    lattice, spins = ising1000(n=n, nsteps=nsteps, T=T)
    
with open(os.path.join(wd,'temp-{1}.out'.format(wd, index)), 'w') as f:
    for i, spin in enumerate(spins):
        if i % 1000 == 0:
            f.write("{0}\t{1}\n".format(i, spin))   
#+END_SRC

#+RESULTS:



    
*** Submitting jobs

#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ising import *
import os

Ns = [10, 20, 50, 100, 1000]  # System Size
Ns = [100]
T_Tcs = np.linspace(0.5, 1.7, 30)  # T/Tc
Tc = 2.268  # Onsager's Tc

for n in Ns:
    for i, T_Tc in enumerate(T_Tcs):
        T = T_Tc*Tc
        wd = 'magnetization/size-{0}/temp-{1}'.format(n, i)
        if not os.path.exists(wd): 
            os.makedirs(wd)
        if n !=1000:
            write_job_script(wd=wd, n=n, s= n * 1000000, T=T, i=i)
        else:
            write_job_script(wd=wd, n=n, s= n * 1000000, T=T, i=i, nprocs = 1, q ='long')
        run_job(wd)
#+END_SRC

#+RESULTS:


*** Plotting

#+BEGIN_SRC python
from __future__ import division
import matplotlib.pyplot as plt
from ising import *
import os

Ns = [10, 20, 50, 100, 1000]  # System Size
T_Tcs = np.linspace(0.5, 1.7, 30)  # T/Tc
Tc = 2.268  # Onsager's Tc

for n in Ns:
    avgspins = []
    avgspinsqs = []
    for i, T_Tc in enumerate(T_Tcs):
        T = T_Tc*Tc
        indices, spins = np.loadtxt('magnetization/size-{0}/temp-{1}/temp-{1}.out'.format(n,i), unpack =True)
        spins = spins[int(len(spins)/2):]
        avgspin = np.sum(np.abs(spins)) / n ** 2 / len(spins)
        avgspinsq =  np.abs(np.sum(((np.abs(spins) / n ** 2) ** 2)) / len(spins) - avgspin) / T
        avgspins.append(avgspin)
        avgspinsqs.append(avgspinsq)
    plt.plot(T_Tcs, avgspinsqs, 'o-')
plt.savefig('images/susseptibility.png')
plt.show()
#+END_SRC

#+RESULTS:

[[./images/magnetization.png]]


[[./images/susseptibility.png]]


*** Finite Size Scaling

#+BEGIN_SRC python
from __future__ import division
import numpy as np
import matplotlib.pyplot as plt
from pycse import nlinfit
from ising import *

Ns = [50]  # System Size
T_Tcs = np.linspace(0.5, 1.7, 30)  # T/Tc
Tc = 2.268  # Onsager's Tc

for n in Ns:
    avgspins = []
    avgspinsqs = []
    for i, T_Tc in enumerate(T_Tcs):
        T = T_Tc*Tc
        indices, spins = np.loadtxt('magnetization/size-{0}/temp-{1}/temp-{1}.out'.format(n,i), unpack =True)
        spins = spins[int(len(spins)/2):]
        avgspin = np.sum(np.abs(spins)) / n ** 2 / len(spins)
        avgspinsq =  np.abs(np.sum(((np.abs(spins) / n ** 2) ** 2)) / len(spins) - avgspin) / T
        avgspins.append(avgspin)
        avgspinsqs.append(avgspinsq)


# data
Ts = T_Tcs * Tc
plt.plot(Ts, avgspins, 'o')

def M_fit(Ts, Tcinf, beta, a):
    
    M = a * np.abs((Ts - Tcinf) / Tcinf) ** beta
    return M

guess = [2.228, 0.125, 1]
pars, pint, SE = nlinfit(M_fit, Ts[6:12], avgspins[6:12], guess, alpha=0.05)
Tcinf, beta, a = pint
Tfit = np.linspace(Ts[8], Ts[12])
#Tfit = np.linspace(Ts.min(), Ts.max())
print pars
#M = M_fit(Tfit, *pars)
#print np.size(Tfit), np.size(M)
#print M
plt.plot(Tfit, M_fit(Tfit, *pars))
#plt.savefig('images/eos-uncertainty.png')

#print '95% confidence intervals'
#print 'V0 = {0} bohr**3'.format(V0)
#print 'E0 = {0} Ha'.format(E0)
#print 'B0 = {0} GPA'.format([x * 29421.010901602753 for x in B0])
plt.show()
#+END_SRC

#+RESULTS:
: [ 2.23332287  0.07938568  1.08890594]


** Extra Credit

#+BEGIN_SRC python
from ising import *

n = 20
T = [0.5, 5.0]

ij = [10, 10]



#+END_SRC

** Nlinfit test

#+BEGIN_SRC python
from pycse import *
import matplotlib.pyplot as plt

x = np.arange(10)
y = x**2 + np.random.random(10)*2
print x , y
plt.plot(x,y)
#plt.show()

def func(x, a):

   return x**a

p, pint, se = nlinfit(func, x, y, 3)

print p
plt.plot(x, x**p)
#def func
plt.show()
#+END_SRC

#+RESULTS:
: [0 1 2 3 4 5 6 7 8 9] [  0.14825736   1.16691747   4.22080684  10.17593107  16.1183198
:   26.82922114  37.29249587  49.31862283  64.13961865  81.82408933]
: [ 2.00562762]


** Gezelter's Code

#+BEGIN_SRC python
from __future__ import division
from math import exp
from random import randrange,choice,random
from numpy import zeros, sum
import numpy as np
import matplotlib.pyplot as plt

def init_ising_lattice(n):
    lattice = zeros((n,n),dtype=int)
    options = [-1,1]
    for i in range(n):
        for j in range(n):
            lattice[i,j] = choice(options)
    return lattice

def energydiff(S0,Sn,J,H): return 2*S0*(H+J*Sn)

def ising(n=200,nsteps=500000,H=0,J=1,T=1):
    lattice = init_ising_lattice(n)
    energy = 0
    
    energies = []
    mags = []
    for step in range(nsteps):
        i = randrange(n)
        j = randrange(n)
        Sn = lattice[(i-1)%n,j]+lattice[(i+1)%n,j]+\
             lattice[i,(j-1)%n]+lattice[i,(j+1)%n]
        dE = energydiff(lattice[i,j],Sn,J,H)
        if dE < 0 or np.random.random() < exp(-dE/T):
            lattice[i,j] = -lattice[i,j]
            energy += dE
        
            energies.append(energy)
        mag = np.sum(lattice)/n**2
        mags.append(mag)
    return lattice,energies, mags

# Plotting Energies
for T in [8.04]:

    lattice, energies, mags = ising(T=T)
    plt.plot(range(len(energies)), energies)

plt.show()
#+END_SRC

#+RESULTS:

   
** Tinkter
   
#+BEGIN_SRC python
# ising.py
# Simulates the two-dimensional Ising model using the Metropolis algorithm
# This version uses Tkinter for the GUI
# By Dan Schroeder, Weber State University, January 2013

import Tkinter, numpy, random, math

size = 100                           # number of sites in a lattice row (change if desired)
squareWidth = 4                    # width of one site in pixels (change if desired)
canvasWidth = size * squareWidth    # full width of canvas in pixels
s = numpy.ones((size, size), int)   # 2D array of dipoles (1=up, -1=down)
running = False                     # will be true when simulation is running

theWindow = Tkinter.Tk()            # create the GUI window
theWindow.title("Ising Model")
theWindow.geometry('+50+50')        # get the window away from the corner

# Here's the Canvas where we draw the lattice using a Tkinter PhotoImage:
theCanvas = Tkinter.Canvas(theWindow, width=canvasWidth, height=canvasWidth)
theCanvas.pack()                    # put it at the top of the window
theImage = Tkinter.PhotoImage(width=canvasWidth, height=canvasWidth)
theCanvas.create_image((0, 0), image=theImage, anchor="nw", state="normal")
# The coordinates (3, 3) are a kludge to eliminate a mysterious offset that occurs otherwise.

# Function called when Start/Stop button is pressed:
def startStop():
    global running
    running = not running
    if running:
        goButton.config(text="Pause")
    else:
        goButton.config(text="Resume")

# Create the GUI controls:
controlFrame = Tkinter.Frame(theWindow)        # a frame to hold the GUI controls
controlFrame.pack()                            # put it below the canvas
tLabel = Tkinter.Label(controlFrame, text="Temperature: ")
tLabel.pack(side="left")
tSlider = Tkinter.Scale(controlFrame, from_=0.01, to=10.0, resolution=0.01, length=120, orient="horizontal")
tSlider.pack(side="left")
tSlider.set(2.27)                              # set to critical temperature initially
spacer = Tkinter.Frame(controlFrame, width=40)
spacer.pack(side="left")
goButton = Tkinter.Button(controlFrame, text="Start", width=8, command=startStop)
goButton.pack(side="left")

# Function to color the square representing site (i,j):
def colorSquare(i, j):
    theColor = "#7000ff" if s[i,j]==1 else "#ffffff"    # purple and white
    theImage.put(theColor, to=(i*squareWidth,j*squareWidth,(i+1)*squareWidth,(j+1)*squareWidth))
    # the "put" function colors the indicated rectangle within the image

# Function to calculate energy change upon hypothetical flip (with pbc):
def deltaE(i,j):
    leftS = s[size-1,j] if i==0 else s[i-1,j]
    rightS = s[0,j] if i==size-1 else s[i+1,j]
    topS = s[i,size-1] if j==0 else s[i,j-1]
    bottomS = s[i,0] if j==size-1 else s[i,j+1]
    return 2.0 * s[i,j] * (leftS + rightS + topS + bottomS)

# Main simulation "loop" schedules a call to itself upon completion:
def simulate():
    if running:
        T = tSlider.get()                    # get the current temperature
        for step in range(1000):             # (change the number of steps as desired)
            i = int(random.random()*size)    # choose a random row and column
            j = int(random.random()*size)
            eDiff = deltaE(i,j)
            if eDiff <= 0 or random.random() < math.exp(-eDiff/T):    # Metropolis!
                s[i,j] = -s[i,j]
                colorSquare(i, j)
    theWindow.after(1,simulate)              # come back in one millisecond

# Initialize to a random array, and draw it as we go:
for i in range(size):
    for j in range(size):
        s[i,j] = 1 if random.random()<0.5 else -1
        colorSquare(i,j)

simulate()                # start the simulation!
theWindow.mainloop()      # start the GUI event loop

#+END_SRC

#+RESULTS:






#+BEGIN_SRC sh
#!/bin/bash

for n in $(seq 230622 230657)

do
  qdel $n

done
#+END_SRC

#+RESULTS:
#+begin_example
pmehta1 has registered the job 230622 for deletion
pmehta1 has registered the job 230623 for deletion
pmehta1 has registered the job 230624 for deletion
pmehta1 has registered the job 230625 for deletion
pmehta1 has registered the job 230626 for deletion
pmehta1 has registered the job 230627 for deletion
pmehta1 has registered the job 230628 for deletion
pmehta1 has registered the job 230629 for deletion
pmehta1 has registered the job 230630 for deletion
pmehta1 has registered the job 230631 for deletion
pmehta1 has registered the job 230632 for deletion
pmehta1 has registered the job 230633 for deletion
pmehta1 has registered the job 230634 for deletion
pmehta1 has registered the job 230635 for deletion
pmehta1 has registered the job 230636 for deletion
pmehta1 has registered the job 230637 for deletion
pmehta1 has registered the job 230638 for deletion
pmehta1 has registered the job 230639 for deletion
pmehta1 has registered the job 230640 for deletion
pmehta1 has registered the job 230641 for deletion
pmehta1 has registered the job 230642 for deletion
pmehta1 has registered the job 230643 for deletion
pmehta1 has registered the job 230644 for deletion
pmehta1 has registered the job 230645 for deletion
pmehta1 has registered the job 230646 for deletion
pmehta1 has registered the job 230647 for deletion
pmehta1 has registered the job 230648 for deletion
pmehta1 has registered the job 230649 for deletion
pmehta1 has registered the job 230650 for deletion
pmehta1 has registered the job 230651 for deletion
pmehta1 has registered the job 230652 for deletion
pmehta1 has registered the job 230653 for deletion
pmehta1 has registered the job 230654 for deletion
pmehta1 has registered the job 230655 for deletion
pmehta1 has registered the job 230656 for deletion
pmehta1 has registered the job 230657 for deletion
#+end_example




** Functional form test

#+BEGIN_SRC python
import numpy as np

T = np.linspace(0.7, 2.0,100) *  2.268
Tc = 2.268

M = np.abs((T - Tc))**0.125

import matplotlib.pyplot as plt
plt.plot(T, M)
print M
plt.show()

#+END_SRC

#+RESULTS:
#+begin_example
[ 0.95300579  0.94768886  0.94215454  0.93638284  0.93035082  0.92403193
  0.91739527  0.91040448  0.90301642  0.89517933  0.88683034  0.87789196
  0.86826715  0.85783197  0.84642447  0.8338271   0.81973737  0.80371612
  0.78508838  0.76273247  0.73455818  0.69586884  0.63121174  0.51006994
  0.65616398  0.70940744  0.74404459  0.77010546  0.79115273  0.80888584
  0.82425454  0.83784603  0.85004977  0.86113794  0.87130856  0.88071039
  0.8894581   0.89764209  0.9053349   0.91259565  0.91947323  0.92600852
  0.93223607  0.93818534  0.94388171  0.94934713  0.9546008   0.95965955
  0.96453824  0.96925008  0.97380684  0.97821905  0.98249621  0.98664687
  0.99067878  0.994599    0.99841395  1.00212951  1.00575108  1.00928359
  1.01273163  1.01609939  1.01939079  1.02260943  1.02575869  1.02884168
  1.03186134  1.03482037  1.03772133  1.04056662  1.04335846  1.04609897
  1.04879012  1.05143379  1.05403174  1.05658562  1.059097    1.06156738
  1.06399816  1.06639068  1.0687462   1.07106593  1.07335102  1.07560256
  1.07782158  1.08000907  1.08216598  1.08429321  1.08639162  1.08846204
  1.09050525  1.09252202  1.09451305  1.09647905  1.09842067  1.10033857
  1.10223335  1.1041056   1.10595588  1.10778475]
#+end_example

